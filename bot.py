import os
import glob
import json
import logging
import asyncio
from datetime import datetime, timedelta

from aiogram import Bot, Dispatcher, types
from aiogram.filters import Command
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.types import Message
from aiogram.utils.text_decorations import MarkdownDecoration
from dotenv import load_dotenv
from aiogram.client.default import DefaultBotProperties
from aiogram.fsm.state import State, StatesGroup
from aiogram.fsm.context import FSMContext
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton
import aiohttp
from bs4 import BeautifulSoup
from config import ParsingConfig

# –ó–∞–≥—Ä—É–∑–∫–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
load_dotenv()
API_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
ADMIN_CHAT_ID = os.getenv("ADMIN_CHAT_ID")

SUBSCRIBERS_FILE = "data/subscribers.json"
SPAM_FILE = "data/antispam.json"
CACHE_FILE = "data/cache.json"
CACHE_TTL_DAYS = 10

logging.basicConfig(level=logging.INFO)

bot = Bot(token=API_TOKEN, default=DefaultBotProperties(parse_mode="MarkdownV2"))
dp = Dispatcher(storage=MemoryStorage())

md = MarkdownDecoration()

# --- FSM States ---
class BuildStates(StatesGroup):
    choose_game = State()
    choose_element = State()
    choose_character = State()

# --- –ö–Ω–æ–ø–∫–∏ ---
GAMES = ["Honkai: Star Rail"]
ELEMENTS = ["–û–≥–æ–Ω—å", "–õ—ë–¥", "–í–µ—Ç–µ—Ä", "–ö–≤–∞–Ω—Ç", "–§–∏–∑–∏–∫–∞", "–ú–Ω–∏–º–æ—Å—Ç—å", "–≠–ª–µ–∫—Ç—Ä–æ"]
# –ü—Ä–∏–º–µ—Ä–Ω—ã–µ –ø–µ—Ä—Å–æ–Ω–∞–∂–∏, –ø–æ—Ç–æ–º –±—É–¥–µ—Ç –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏
CHARACTERS = {
    "–û–≥–æ–Ω—å": ["–ê—Å—Ç–∞", "–•–∏–º–µ–∫–æ", "–ú–∞—Ä—á 7th"],
    "–õ—ë–¥": ["–ì–µ–ø–∞—Ä–¥", "–ü–µ–ª–∞", "–Ø–Ω—å—Ü–∏–Ω"],
    # ... –æ—Å—Ç–∞–ª—å–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã
}

CHARACTER_LIST_URL = "https://game8.co/games/Honkai-Star-Rail/archives/404256"

# --- –≠–º–æ–¥–∑–∏ –¥–ª—è —ç–ª–µ–º–µ–Ω—Ç–æ–≤ ---
ELEMENT_EMOJI = {
    "Fire": "üî•",
    "Ice": "‚ùÑÔ∏è",
    "Wind": "üå™Ô∏è",
    "Quantum": "‚öõÔ∏è",
    "Physical": "üí™",
    "Imaginary": "üåà",
    "Lightning": "‚ö°"
}

def load_json(path, default):
    if os.path.exists(path):
        with open(path, "r", encoding="utf-8") as f:
            return json.load(f)
    return default

def save_json(path, data):
    with open(path, "w", encoding="utf-8") as f:
        json.dump(data, f, ensure_ascii=False)

def get_latest_build_file():
    files = glob.glob("data/builds_*.json")
    if not files:
        return None
    return max(files, key=os.path.getctime)

def format_build(build):
    name = md.quote(build.get("name", ""))
    build_type = md.quote(build.get("build_type", ""))
    weapon = md.quote(build.get("weapon", ""))
    artifacts = build.get("artifacts", {})
    art_str = "\n".join([f"*{md.quote(k)}*: {md.quote(v)}" for k, v in artifacts.items()])
    return (
        f"*{name}*\n"
        f"_{build_type}_\n"
        f"*–û—Ä—É–∂–∏–µ*: {weapon}\n"
        f"*–ê—Ä—Ç–µ—Ñ–∞–∫—Ç—ã*:\n{art_str}\n"
        "----------------------"
    )

def make_keyboard(options, add_back=False):
    keyboard = [[KeyboardButton(text=o)] for o in options]
    if add_back:
        keyboard.append([KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥")])
    return ReplyKeyboardMarkup(keyboard=keyboard, resize_keyboard=True)

# --- –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–µ –∫–Ω–æ–ø–∫–∏ –∏–∑ –∫—ç—à–∞ ---
def get_elements_from_cache():
    cache = load_cache()
    return list(cache.get("elements", {}).keys())

def get_characters_from_cache(element):
    cache = load_cache()
    return cache.get("elements", {}).get(element, [])

# --- FSM-–¥–∏–∞–ª–æ–≥ —Å –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–º–∏ –∫–Ω–æ–ø–∫–∞–º–∏ –∏ –∫–Ω–æ–ø–∫–æ–π '–ù–∞–∑–∞–¥' ---
@dp.message(Command("start"))
async def cmd_start(message: Message, state: FSMContext):
    await message.answer(md.quote("–ü—Ä–∏–≤–µ—Ç! –î–ª—è –∫–∞–∫–æ–π –∏–≥—Ä—ã —Ç–µ–±–µ –Ω—É–∂–Ω–∞ —Å–±–æ—Ä–∫–∞?"), reply_markup=make_keyboard(GAMES))
    await state.set_state(BuildStates.choose_game)

@dp.message(BuildStates.choose_game)
async def choose_game(message: Message, state: FSMContext):
    if message.text not in GAMES:
        await message.answer(md.quote("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏ –∏–≥—Ä—É —Å –ø–æ–º–æ—â—å—é –∫–Ω–æ–ø–∫–∏."), reply_markup=make_keyboard(GAMES))
        return
    await state.update_data(game=message.text)
    elements = get_elements_from_cache()
    # –î–æ–±–∞–≤–ª—è–µ–º —ç–º–æ–¥–∑–∏ –∫ —ç–ª–µ–º–µ–Ω—Ç–∞–º
    elements_with_emoji = [f"{ELEMENT_EMOJI.get(e, '')} {e}".strip() for e in elements]
    await message.answer(md.quote("–í—ã–±–µ—Ä–∏ —ç–ª–µ–º–µ–Ω—Ç –ø–µ—Ä—Å–æ–Ω–∞–∂–∞:"), reply_markup=make_keyboard(elements_with_emoji, add_back=True))
    await state.set_state(BuildStates.choose_element)

@dp.message(BuildStates.choose_element)
async def choose_element(message: Message, state: FSMContext):
    elements = get_elements_from_cache()
    elements_with_emoji = [f"{ELEMENT_EMOJI.get(e, '')} {e}".strip() for e in elements]
    # –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–Ω–æ–ø–∫–∏ '–ù–∞–∑–∞–¥'
    if message.text == "‚¨ÖÔ∏è –ù–∞–∑–∞–¥":
        await message.answer(md.quote("–î–ª—è –∫–∞–∫–æ–π –∏–≥—Ä—ã —Ç–µ–±–µ –Ω—É–∂–Ω–∞ —Å–±–æ—Ä–∫–∞?"), reply_markup=make_keyboard(GAMES))
        await state.set_state(BuildStates.choose_game)
        return
    # –£–±–∏—Ä–∞–µ–º —ç–º–æ–¥–∑–∏ –¥–ª—è —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏—è
    element_map = {f"{ELEMENT_EMOJI.get(e, '')} {e}".strip(): e for e in elements}
    if message.text not in element_map:
        await message.answer(md.quote("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏ —ç–ª–µ–º–µ–Ω—Ç —Å –ø–æ–º–æ—â—å—é –∫–Ω–æ–ø–∫–∏."), reply_markup=make_keyboard(elements_with_emoji, add_back=True))
        return
    element = element_map[message.text]
    await state.update_data(element=element)
    chars = get_characters_from_cache(element)
    await message.answer(md.quote("–í—ã–±–µ—Ä–∏ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞:"), reply_markup=make_keyboard(chars, add_back=True))
    await state.set_state(BuildStates.choose_character)

def mdv2_list(items):
    return "\n".join(f"\\- {md.quote(i)}" for i in items)

@dp.message(BuildStates.choose_character)
async def choose_character(message: Message, state: FSMContext):
    data = await state.get_data()
    chars = get_characters_from_cache(data.get("element"))
    # –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–Ω–æ–ø–∫–∏ '–ù–∞–∑–∞–¥'
    if message.text == "‚¨ÖÔ∏è –ù–∞–∑–∞–¥":
        elements = get_elements_from_cache()
        elements_with_emoji = [f"{ELEMENT_EMOJI.get(e, '')} {e}".strip() for e in elements]
        await message.answer(md.quote("–í—ã–±–µ—Ä–∏ —ç–ª–µ–º–µ–Ω—Ç –ø–µ—Ä—Å–æ–Ω–∞–∂–∞:"), reply_markup=make_keyboard(elements_with_emoji, add_back=True))
        await state.set_state(BuildStates.choose_element)
        return
    if message.text not in chars:
        await message.answer(md.quote("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞ —Å –ø–æ–º–æ—â—å—é –∫–Ω–æ–ø–∫–∏."), reply_markup=make_keyboard(chars, add_back=True))
        return
    await state.update_data(character=message.text)
    await message.answer(md.quote(f"–ò—â—É —Å–≤–µ–∂–∏–π –±–∏–ª–¥ –¥–ª—è {message.text}..."), reply_markup=types.ReplyKeyboardRemove())
    build = await get_build(message.text)
    # –ù–æ–≤—ã–π —Ñ–æ—Ä–º–∞—Ç –≤—ã–¥–∞—á–∏
    text = format_build_v2(message.text, build)
    if not text.strip():
        text = md.quote("–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –ø–æ –±–∏–ª–¥—É —ç—Ç–æ–≥–æ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞.")
    await message.answer(text)
    await state.clear()

@dp.message(Command("latest"))
async def cmd_latest(message: Message):
    # –ê–Ω—Ç–∏—Å–ø–∞–º: –Ω–µ —á–∞—â–µ 1 —Ä–∞–∑–∞ –≤ 30 —Å–µ–∫—É–Ω–¥
    antispam = load_json(SPAM_FILE, {})
    user_id = str(message.from_user.id)
    now = datetime.utcnow()
    last = antispam.get(user_id)
    if last and (now - datetime.fromisoformat(last)) < timedelta(seconds=30):
        await message.answer(md.quote("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–µ —Å–ø–∞–º—å—Ç–µ! –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."))
        return
    antispam[user_id] = now.isoformat()
    save_json(SPAM_FILE, antispam)

    file = get_latest_build_file()
    if not file:
        await message.answer(md.quote("–ù–µ—Ç —Å–≤–µ–∂–∏—Ö –±–∏–ª–¥–æ–≤."))
        return
    with open(file, "r", encoding="utf-8") as f:
        builds = json.load(f)
    for build in builds[:10]:
        await message.answer(md.quote(format_build(build)))

@dp.message(Command("subscribe"))
async def cmd_subscribe(message: Message):
    subs = set(load_json(SUBSCRIBERS_FILE, []))
    subs.add(message.from_user.id)
    save_json(SUBSCRIBERS_FILE, list(subs))
    await message.answer(md.quote("–í—ã –ø–æ–¥–ø–∏—Å–∞–ª–∏—Å—å –Ω–∞ –µ–∂–µ–¥–Ω–µ–≤–Ω—É—é —Ä–∞—Å—Å—ã–ª–∫—É!"))

@dp.message(Command("unsubscribe"))
async def cmd_unsubscribe(message: Message):
    subs = set(load_json(SUBSCRIBERS_FILE, []))
    subs.discard(message.from_user.id)
    save_json(SUBSCRIBERS_FILE, list(subs))
    await message.answer(md.quote("–í—ã –æ—Ç–ø–∏—Å–∞–ª–∏—Å—å –æ—Ç —Ä–∞—Å—Å—ã–ª–∫–∏."))

@dp.error()
async def error_handler(event, error):
    logging.error(f"–û—à–∏–±–∫–∞: {error}")
    if isinstance(event, Message):
        await event.answer(md.quote("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."))
    if ADMIN_CHAT_ID:
        try:
            await bot.send_message(ADMIN_CHAT_ID, md.quote(f"Error: {error}"))
        except Exception:
            pass

async def daily_broadcast():
    while True:
        subs = set(load_json(SUBSCRIBERS_FILE, []))
        file = get_latest_build_file()
        if file:
            with open(file, "r", encoding="utf-8") as f:
                builds = json.load(f)
            text = "\n\n".join([format_build(b) for b in builds[:3]])
            for uid in subs:
                try:
                    await bot.send_message(uid, text)
                except Exception as e:
                    logging.warning(f"Can't send to {uid}: {e}")
        await asyncio.sleep(24 * 3600)

async def fetch_build_from_game8(character_name: str) -> dict:
    cache = load_cache()
    char_link = cache.get("links", {}).get(character_name)
    if not char_link:
        logging.warning(f"–ù–µ—Ç —Å—Å—ã–ª–∫–∏ –Ω–∞ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞ {character_name}")
        return {
            "relics": {"best": "", "alternative": ""},
            "light_cones": {"best": "", "alternative_4": "", "alternative_3": ""},
            "stats": {"main": {"body": "", "feet": "", "sphere": "", "rope": ""}},
            "priority_stats": {},
            "ornaments": {"best": "", "alternative": ""},
            "tips": ""
        }
    async with aiohttp.ClientSession() as session:
        async with session.get(char_link) as resp:
            html = await resp.text()
    soup = BeautifulSoup(html, "html.parser")
    build = {
        "relics": {"best": "", "alternative": ""},
        "light_cones": {"best": "", "alternative_4": "", "alternative_3": ""},
        "stats": {"main": {"body": "", "feet": "", "sphere": "", "rope": ""}},
        "priority_stats": {},
        "ornaments": {"best": "", "alternative": ""},
        "tips": ""
    }
    
    # --- Relics ---
    def find_section(header_keywords):
        for tag in soup.find_all(["h2", "h3"]):
            if any(kw.lower() in tag.text.lower() for kw in header_keywords):
                return tag
        return None
    
    # Relics
    relics_header = find_section(["Relics and Ornaments", "–†–µ–ª–∏–∫–≤–∏–∏ –∏ —É–∫—Ä–∞—à–µ–Ω–∏—è"])
    if relics_header:
        section = relics_header.find_next(["ul", "table"])
        if section:
            relics = []
            if section.name == "ul":
                # –ò–∑–≤–ª–µ–∫–∞–µ–º —Ç–µ–∫—Å—Ç –∏ —Å—Å—ã–ª–∫–∏
                for li in section.find_all("li"):
                    text = li.get_text(strip=True)
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ —Å—Å—ã–ª–∫–∏
                    link = li.find("a")
                    if link and link.get("href"):
                        text += f" ([—Å—Å—ã–ª–∫–∞]({link.get('href')})"
                    relics.append(text)
            elif section.name == "table":
                for row in section.find_all("tr"):
                    cells = row.find_all("td")
                    if cells:
                        text = cells[0].get_text(strip=True)
                        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ —Å—Å—ã–ª–∫–∏
                        link = cells[0].find("a")
                        if link and link.get("href"):
                            text += f" ([—Å—Å—ã–ª–∫–∞]({link.get('href')})"
                        relics.append(text)
            
            # –ò–∑–≤–ª–µ–∫–∞–µ–º –ª—É—á—à–∏–π –∏ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π —Å–µ—Ç—ã
            build["relics"]["best"] = extract_best(relics)
            build["relics"]["alternative"] = extract_alternative(relics)
    
    # Light Cones
    cones_header = find_section(ParsingConfig.SECTIONS["light_cones"])
    if cones_header:
        section = cones_header.find_next(["ul", "table"])
        if section:
            cones = []
            if section.name == "ul":
                # –ò–∑–≤–ª–µ–∫–∞–µ–º —Ç–µ–∫—Å—Ç –∏ —Å—Å—ã–ª–∫–∏
                for li in section.find_all("li"):
                    text = li.get_text(strip=True)
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ —Å—Å—ã–ª–∫–∏
                    link = li.find("a")
                    if link and link.get("href"):
                        text += f" ([—Å—Å—ã–ª–∫–∞]({link.get('href')})"
                    cones.append(text)
            elif section.name == "table":
                for row in section.find_all("tr"):
                    cells = row.find_all("td")
                    if cells:
                        text = cells[0].get_text(strip=True)
                        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ —Å—Å—ã–ª–∫–∏
                        link = cells[0].find("a")
                        if link and link.get("href"):
                            text += f" ([—Å—Å—ã–ª–∫–∞]({link.get('href')})"
                        cones.append(text)
            
            # –ò–∑–≤–ª–µ–∫–∞–µ–º –ª—É—á—à–∏–π 5‚òÖ –∫–æ–Ω—É—Å
            build["light_cones"]["best"] = extract_best(cones)
            # –ò–∑–≤–ª–µ–∫–∞–µ–º –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π 4‚òÖ –∫–æ–Ω—É—Å
            build["light_cones"]["alternative_4"] = extract_alternative(cones)
            # –ò–∑–≤–ª–µ–∫–∞–µ–º –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π 3‚òÖ –∫–æ–Ω—É—Å
            for cone in cones:
                if "3‚òÖ" in cone or "3*" in cone or "3-star" in cone.lower():
                    build["light_cones"]["alternative_3"] = cone
                    break
            # –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ 3‚òÖ –∫–æ–Ω—É—Å, –∏—â–µ–º –ø–µ—Ä–≤—ã–π –ø–æ–¥—Ö–æ–¥—è—â–∏–π –ø–æ —Ä–µ–π—Ç–∏–Ω–≥—É
            if not build["light_cones"]["alternative_3"]:
                for cone in cones:
                    if "‚òÖ" in cone:
                        rating = cone.count("‚òÖ")
                        if rating <= 3:
                            build["light_cones"]["alternative_3"] = cone
                            break
            # –ï—Å–ª–∏ –≤—Å–µ –µ—â–µ –Ω–µ –Ω–∞—à–ª–∏, –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
            if not build["light_cones"]["alternative_3"]:
                build["light_cones"]["alternative_3"] = "Cruising in the Stellar Sea"
    
    # Stats
    stats_header = find_section(ParsingConfig.SECTIONS["stats"])
    if stats_header:
        section = stats_header.find_next(["ul", "table"])
        if section:
            if section.name == "ul":
                build["stats"] = [li.get_text(strip=True) for li in section.find_all("li")]
            elif section.name == "table":
                for row in section.find_all("tr"):
                    cells = row.find_all("td")
                    if cells:
                        build["stats"].append(cells[0].get_text(strip=True))
    else:
        # –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ —Å–µ–∫—Ü–∏—é —Å —Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–Ω—ã–º–∏ —Å—Ç–∞—Ç–∞–º–∏, –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è
        build["stats"]["main"] = {
            "body": "Break Effect",
            "feet": "SPD",
            "sphere": "CRIT Rate",
            "rope": "Energy Regen"
        }
    
    # Priority Stats
    priority_header = find_section(ParsingConfig.SECTIONS["priority"])
    if priority_header:
        section = priority_header.find_next(["ul", "table"])
        if section:
            if section.name == "ul":
                for li in section.find_all("li"):
                    text = li.get_text(strip=True)
                    # –ò–∑–≤–ª–µ–∫–∞–µ–º —Ä–µ–π—Ç–∏–Ω–≥ –∏ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫—É –±–æ–ª–µ–µ –≥–∏–±–∫–æ
                    parts = text.split(" - ")
                    if len(parts) >= 2:
                        rating_text = parts[0].strip().lower()
                        stat = parts[1].strip()
                        
                        # –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–∞–∑–Ω—ã—Ö —Ñ–æ—Ä–º–∞—Ç–æ–≤ —Ä–µ–π—Ç–∏–Ω–≥–∞
                        if "‚òÖ" in rating_text:
                            rating = rating_text.count("‚òÖ")
                        elif "star" in rating_text:
                            rating = int(rating_text.split("-star")[0])
                        elif any(num in rating_text for num in "12345"):
                            rating = int(rating_text[0])
                        else:
                            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–µ–∫—Å—Ç–æ–≤—ã–µ –æ—Ü–µ–Ω–∫–∏
                            for text_rating in ParsingConfig.RATING_TEXT_TO_NUM:
                                if text_rating in rating_text:
                                    rating = ParsingConfig.RATING_TEXT_TO_NUM[text_rating]
                                    break
                            else:
                                # –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ –ø–æ–¥—Ö–æ–¥—è—â–∏–π —Ñ–æ—Ä–º–∞—Ç, –∏—Å–ø–æ–ª—å–∑—É–µ–º 3 –∑–≤–µ–∑–¥—ã –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
                                rating = 3
                        build["priority_stats"][stat] = rating
            elif section.name == "table":
                for row in section.find_all("tr"):
                    cells = row.find_all("td")
                    if len(cells) >= 2:
                        rating_text = cells[0].get_text(strip=True).lower()
                        stat = cells[1].get_text(strip=True)
                        # –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–µ–π—Ç–∏–Ω–≥–∞ –∫–∞–∫ –≤ —Å–ø–∏—Å–∫–µ
                        if "‚òÖ" in rating_text:
                            rating = rating_text.count("‚òÖ")
                        elif "star" in rating_text:
                            rating = int(rating_text.split("-star")[0])
                        elif any(num in rating_text for num in "12345"):
                            rating = int(rating_text[0])
                        else:
                            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–µ–∫—Å—Ç–æ–≤—ã–µ –æ—Ü–µ–Ω–∫–∏
                            for text_rating in ParsingConfig.RATING_TEXT_TO_NUM:
                                if text_rating in rating_text:
                                    rating = ParsingConfig.RATING_TEXT_TO_NUM[text_rating]
                                    break
                            else:
                                # –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ –ø–æ–¥—Ö–æ–¥—è—â–∏–π —Ñ–æ—Ä–º–∞—Ç, –∏—Å–ø–æ–ª—å–∑—É–µ–º 3 –∑–≤–µ–∑–¥—ã –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
                                rating = 3
                        build["priority_stats"][stat] = rating
    else:
        # –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ —Å–µ–∫—Ü–∏—é —Å —Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–Ω—ã–º–∏ —Å—Ç–∞—Ç–∞–º–∏, –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è
        build["stats"]["main"] = {
            "body": "Break Effect",
            "feet": "SPD",
            "sphere": "CRIT Rate",
            "rope": "Energy Regen"
        }
    
    # Planar Ornaments
    planar_header = find_section(ParsingConfig.SECTIONS["ornaments"])
    if planar_header:
        section = planar_header.find_next(["ul", "table"])
        if section:
            if section.name == "ul":
                # –ò–∑–≤–ª–µ–∫–∞–µ–º —Ç–µ–∫—Å—Ç –∏ —Å—Å—ã–ª–∫–∏
                for li in section.find_all("li"):
                    text = li.get_text(strip=True)
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ —Å—Å—ã–ª–∫–∏
                    link = li.find("a")
                    if link and link.get("href"):
                        text += f" ([—Å—Å—ã–ª–∫–∞]({link.get('href')})"
                    # –ò—â–µ–º –ª—É—á—à–∏–π –≤–∞—Ä–∏–∞–Ω—Ç –ø–æ –∫–ª—é—á–µ–≤—ã–º —Å–ª–æ–≤–∞–º
                    if any(word in text.lower() for word in ParsingConfig.BEST_KEYWORDS):
                        build["ornaments"]["best"] = text
                    # –ò—â–µ–º –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π –≤–∞—Ä–∏–∞–Ω—Ç –ø–æ –∫–ª—é—á–µ–≤—ã–º —Å–ª–æ–≤–∞–º
                    elif any(word in text.lower() for word in ParsingConfig.ALTERNATIVE_KEYWORDS):
                        build["ornaments"]["alternative"] = text
                # –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ —è–≤–Ω–æ, –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø–µ—Ä–≤—ã–π –∏ –≤—Ç–æ—Ä–æ–π —ç–ª–µ–º–µ–Ω—Ç—ã
                if not build["ornaments"]["best"] and len(section.find_all("li")) >= 1:
                    build["ornaments"]["best"] = section.find_all("li")[0].get_text(strip=True)
                if not build["ornaments"]["alternative"] and len(section.find_all("li")) >= 2:
                    build["ornaments"]["alternative"] = section.find_all("li")[1].get_text(strip=True)
            elif section.name == "table":
                rows = section.find_all("tr")
                if len(rows) >= 2:
                    # –ë–µ—Ä–µ–º –ø–µ—Ä–≤—ã–µ –¥–≤–∞ —Ä—è–¥–∞ –∫–∞–∫ –ª—É—á—à–∏–π –∏ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π –≤–∞—Ä–∏–∞–Ω—Ç—ã
                    build["ornaments"]["best"] = rows[0].find_all("td")[0].get_text(strip=True)
                    build["ornaments"]["alternative"] = rows[1].find_all("td")[0].get_text(strip=True)
    else:
        # –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ —Å–µ–∫—Ü–∏—é —Å —É–∫—Ä–∞—à–µ–Ω–∏—è–º–∏, –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è
        build["ornaments"]["best"] = ParsingConfig.DEFAULT_ORNAMENT
        build["ornaments"]["alternative"] = "Giant Tree of Rapt Brooding"
    
    # Tips
    tips_header = find_section(["Gameplay Guide", "–†—É–∫–æ–≤–æ–¥—Å—Ç–≤–æ –ø–æ –∏–≥—Ä–µ"])
    if tips_header:
        p = tips_header.find_next("p")
        if p:
            build["tips"] = p.get_text(strip=True)
    
    logging.info(f"–ë–∏–ª–¥ –¥–ª—è {character_name}: {build}")
    return build
    # Stats
    stats_header = find_section(["Recommended Stats", "–†–µ–∫–æ–º–µ–Ω–¥—É–µ–º—ã–µ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏"])
    if stats_header:
        section = stats_header.find_next(["ul", "table"])
        if section:
            if section.name == "ul":
                build["stats"] = [li.get_text(strip=True) for li in section.find_all("li")]
            elif section.name == "table":
                for row in section.find_all("tr"):
                    cells = row.find_all("td")
                    if cells:
                        build["stats"].append(cells[0].get_text(strip=True))
    # Planar Ornaments
    planar_header = find_section(["Planar Ornaments", "–ü–ª–∞–Ω–∞—Ä–Ω—ã–µ —É–∫—Ä–∞—à–µ–Ω–∏—è"])
    if planar_header:
        section = planar_header.find_next(["ul", "table"])
        if section:
            if section.name == "ul":
                # –ò–∑–≤–ª–µ–∫–∞–µ–º —Ç–µ–∫—Å—Ç –∏ —Å—Å—ã–ª–∫–∏
                for li in section.find_all("li"):
                    text = li.get_text(strip=True)
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ —Å—Å—ã–ª–∫–∏
                    link = li.find("a")
                    if link and link.get("href"):
                        text += f" ([—Å—Å—ã–ª–∫–∞]({link.get('href')}))"
                    build["planar"].append(text)
            elif section.name == "table":
                for row in section.find_all("tr"):
                    cells = row.find_all("td")
                    if cells:
                        text = cells[0].get_text(strip=True)
                        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ —Å—Å—ã–ª–∫–∏
                        link = cells[0].find("a")
                        if link and link.get("href"):
                            text += f" ([—Å—Å—ã–ª–∫–∞]({link.get('href')}))"
                        build["planar"].append(text)
    # Tips
    tips_header = find_section(["Gameplay Guide", "–†—É–∫–æ–≤–æ–¥—Å—Ç–≤–æ –ø–æ –∏–≥—Ä–µ"])
    if tips_header:
        p = tips_header.find_next("p")
        if p:
            build["tips"] = p.get_text(strip=True)
    logging.info(f"–ë–∏–ª–¥ –¥–ª—è {character_name}: {build}")
    return build

# --- –ù–æ–≤—ã–π —Ñ–æ—Ä–º–∞—Ç—Ç–µ—Ä –∏ –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ ---
def extract_best(items):
    """–ò—â–µ—Ç –ª—É—á—à–∏–π –≤–∞—Ä–∏–∞–Ω—Ç –ø–æ –∫–ª—é—á–µ–≤—ã–º —Å–ª–æ–≤–∞–º, –∏–Ω–∞—á–µ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø–µ—Ä–≤—ã–π —ç–ª–µ–º–µ–Ω—Ç."""
    keywords = ["best", "recommended", "signature", "–ª—É—á—à–∏–π", "—Ä–µ–∫–æ–º–µ–Ω–¥—É–µ–º—ã–π"]
    for item in items:
        text = item.lower()
        if any(kw in text for kw in keywords):
            return item
    return items[0] if items else ""

def extract_alternative(items):
    """–ò—â–µ—Ç –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π –≤–∞—Ä–∏–∞–Ω—Ç –ø–æ –∫–ª—é—á–µ–≤—ã–º —Å–ª–æ–≤–∞–º, –∏–Ω–∞—á–µ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –≤—Ç–æ—Ä–æ–π —ç–ª–µ–º–µ–Ω—Ç."""
    keywords = ["alternative", "alt", "2nd", "second", "–∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤", "–≤—Ç–æ—Ä–æ–π"]
    best = extract_best(items)
    # –ò—â–µ–º –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π –≤–∞—Ä–∏–∞–Ω—Ç, –∫–æ—Ç–æ—Ä—ã–π –Ω–µ —Å–æ–≤–ø–∞–¥–∞–µ—Ç —Å –ª—É—á—à–∏–º
    for item in items:
        if item != best:
            text = item.lower()
            if any(kw in text for kw in keywords):
                return item
    # –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ –ø–æ–¥—Ö–æ–¥—è—â–∏–π –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π –≤–∞—Ä–∏–∞–Ω—Ç, –±–µ—Ä–µ–º –ø–µ—Ä–≤—ã–π, –∫–æ—Ç–æ—Ä—ã–π –Ω–µ –ª—É—á—à–∏–π
    for item in items:
        if item != best:
            return item
    return ""



def format_build_v2(character_name, build):
    lines = []
    lines.append(f"*–ë–∏–ª–¥ –¥–ª—è {md.quote(character_name)}*")
    
    # –†–µ–ª–∏–∫–≤–∏–∏
    if build.get("relics"):
        best_relic = build["relics"]["best"]
        alt_relic = build["relics"]["alternative"]
        lines.append(f"\n*–†–µ–∫–æ–º–µ–Ω–¥—É–µ–º—ã–µ —Ä–µ–ª–∏–∫–≤–∏–∏:*\n{md.quote(best_relic)}")
        lines.append(f"\n*–ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–µ —Ä–µ–ª–∏–∫–≤–∏–∏:*\n{md.quote(alt_relic)}")
    
    # –ö–æ–Ω—É—Å—ã
    if build.get("light_cones"):
        best_5 = build["light_cones"]["best"]
        alt_4 = build["light_cones"]["alternative_4"]
        alt_3 = build["light_cones"]["alternative_3"]
        
        lines.append(f"\n*–ö–æ–Ω—É—Å 5‚òÖ:*\n{md.quote(best_5)}")
        lines.append(f"\n*–ö–æ–Ω—É—Å 4‚òÖ:*\n{md.quote(alt_4)}")
        lines.append(f"\n*–ö–æ–Ω—É—Å 3‚òÖ:*\n{md.quote(alt_3)}")
    
    # –û—Å–Ω–æ–≤–Ω—ã–µ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏
    if build.get("stats"):
        main_stats = build["stats"]["main"]
        lines.append("\n*–û—Å–Ω–æ–≤–Ω—ã–µ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏:*")
        for slot, stat in main_stats.items():
            lines.append(f"\n*{slot}*: {md.quote(stat)}")
            
    # –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω—ã–µ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏
    if build.get("priority_stats"):
        priority_stats = build["priority_stats"]
        lines.append("\n*–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω—ã–µ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏:*")
        for stat, rating in priority_stats.items():
            stars = "‚òÖ" * rating
            lines.append(f"\n*{md.quote(stat)}*: {stars}")
    
    # –ü–ª–∞–Ω–∞—Ä–Ω—ã–µ —É–∫—Ä–∞—à–µ–Ω–∏—è
    if build.get("ornaments"):
        best_ornament = build["ornaments"]["best"]
        alt_ornament = build["ornaments"]["alternative"]
        lines.append(f"\n*–ü–ª–∞–Ω–∞—Ä–Ω—ã–µ —É–∫—Ä–∞—à–µ–Ω–∏—è:*\n{md.quote(best_ornament)}")
        lines.append(f"\n*–ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–µ —É–∫—Ä–∞—à–µ–Ω–∏—è:*\n{md.quote(alt_ornament)}")
    
    return "\n".join(lines)

def load_cache():
    if os.path.exists(CACHE_FILE):
        with open(CACHE_FILE, "r", encoding="utf-8") as f:
            return json.load(f)
    return {"updated": "1970-01-01", "data": {}}

def save_cache(cache):
    with open(CACHE_FILE, "w", encoding="utf-8") as f:
        json.dump(cache, f, ensure_ascii=False)

def is_cache_expired(cache):
    updated = datetime.fromisoformat(cache.get("updated", "1970-01-01"))
    return datetime.utcnow() - updated > timedelta(days=CACHE_TTL_DAYS)

async def get_build(character_name: str) -> dict:
    cache = load_cache()
    if character_name in cache["data"] and not is_cache_expired(cache):
        return cache["data"][character_name]
    build = await fetch_build_from_game8(character_name)
    cache["data"][character_name] = build
    cache["updated"] = datetime.utcnow().isoformat()
    save_cache(cache)
    return build

async def fetch_characters_and_elements() -> dict:
    async with aiohttp.ClientSession() as session:
        async with session.get(CHARACTER_LIST_URL) as resp:
            html = await resp.text()
    soup = BeautifulSoup(html, "html.parser")
    # –õ–æ–≥–∏—Ä—É–µ–º –≤—Å–µ –∑–∞–≥–æ–ª–æ–≤–∫–∏ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
    headers = list(soup.find_all(["h2", "h3"]))
    logging.info("–ó–∞–≥–æ–ª–æ–≤–∫–∏ –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ:")
    for h in headers:
        logging.info(f"{h.name}: {h.text.strip()}")
    # –ò—â–µ–º —Ç–∞–±–ª–∏—Ü—É —Å –∞–∫—Ç—É–∞–ª—å–Ω—ã–º–∏ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞–º–∏ –ø–æ –∑–∞–≥–æ–ª–æ–≤–∫—É
    table = None
    for header in headers:
        if any(x in header.text for x in ["All Playable Characters", "List of All Characters", "Playable Characters", "–í—Å–µ –ø–µ—Ä—Å–æ–Ω–∞–∂–∏"]):
            table = header.find_next("table")
            break
    if not table:
        # fallback: –∏—â–µ–º —Ç–∞–±–ª–∏—Ü—É —Å –Ω–∞–∏–±–æ–ª—å—à–∏–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ–º —Å—Ç—Ä–æ–∫
        tables = soup.find_all("table")
        if not tables:
            logging.error("–ù–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ –Ω–µ—Ç –Ω–∏ –æ–¥–Ω–æ–π —Ç–∞–±–ª–∏—Ü—ã!")
            return {"elements": {}, "characters": {}, "links": {}}
        table = max(tables, key=lambda t: len(t.find_all("tr")))
        logging.warning("–ù–µ –Ω–∞–π–¥–µ–Ω –∑–∞–≥–æ–ª–æ–≤–æ–∫ —Å –∞–∫—Ç—É–∞–ª—å–Ω—ã–º–∏ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞–º–∏, –≤—ã–±—Ä–∞–Ω–∞ —Å–∞–º–∞—è –±–æ–ª—å—à–∞—è —Ç–∞–±–ª–∏—Ü–∞ –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ!")
    elements = {}
    characters = {}
    links = {}
    for row in table.find_all("tr")[1:]:  # –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –∑–∞–≥–æ–ª–æ–≤–æ–∫
        cols = row.find_all("td")
        if len(cols) < 4:
            continue
        char_a = cols[0].find("a")
        char_name = char_a.text.strip() if char_a else cols[0].text.strip()
        char_href = char_a["href"] if char_a and char_a.get("href") else None
        if char_href:
            if char_href.startswith("http"):
                char_link = char_href
            else:
                char_link = "https://game8.co" + char_href
        else:
            char_link = None
        element_img = cols[2].find("img")
        element = element_img["alt"].strip() if element_img and element_img.get("alt") else cols[2].text.strip()
        # –ó–∞–ø–æ–ª–Ω—è–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä—ã
        if element not in elements:
            elements[element] = []
        elements[element].append(char_name)
        characters[char_name] = element
        if char_link:
            links[char_name] = char_link
    # –õ–æ–≥–∏—Ä—É–µ–º –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
    logging.info(f"–ù–∞–π–¥–µ–Ω–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤: {list(elements.keys())}")
    for el, chars in elements.items():
        logging.info(f"–≠–ª–µ–º–µ–Ω—Ç {el}: {chars}")
    return {"elements": elements, "characters": characters, "links": links}

# –§—É–Ω–∫—Ü–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∫—ç—à–∞ —Å –ø–µ—Ä—Å–æ–Ω–∞–∂–∞–º–∏ –∏ —ç–ª–µ–º–µ–Ω—Ç–∞–º–∏
async def update_full_cache():
    cache = load_cache()
    char_data = await fetch_characters_and_elements()
    cache["elements"] = char_data["elements"]
    cache["characters"] = char_data["characters"]
    cache["links"] = char_data["links"]
    cache["updated"] = datetime.utcnow().isoformat()
    save_cache(cache)
    return cache

# --- –ê–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫—ç—à–∞ —Ä–∞–∑ –≤ 10 –¥–Ω–µ–π ---
async def cache_auto_updater():
    while True:
        cache = load_cache()
        if is_cache_expired(cache) or not cache.get("elements"):
            try:
                await update_full_cache()
                logging.info("–ö—ç—à –ø–µ—Ä—Å–æ–Ω–∞–∂–µ–π –∏ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –æ–±–Ω–æ–≤–ª—ë–Ω.")
            except Exception as e:
                logging.warning(f"–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∫—ç—à–∞: {e}")
        await asyncio.sleep(24 * 3600)  # –ü—Ä–æ–≤–µ—Ä—è—Ç—å —Ä–∞–∑ –≤ —Å—É—Ç–∫–∏

# --- –∑–∞–ø—É—Å–∫ –∞–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –≤ main ---
async def main():
    await bot.delete_webhook(drop_pending_updates=True)
    asyncio.create_task(daily_broadcast())
    asyncio.create_task(cache_auto_updater())
    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main())
